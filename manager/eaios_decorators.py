import asyncio
import os
import importlib
import functools
import ast
from mcp.server.fastmcp import FastMCP
import yaml
import sys
import inspect
if os.path.abspath(os.path.dirname(__file__)) not in sys.path:
    sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from constant import BASE_SKILL_PATH, INIT_FILE, BASE_PATH

if os.path.dirname(BASE_PATH) not in sys.path:
    sys.path.append(os.path.dirname(BASE_PATH))

# 使用模块属性作为全局注册表
if not hasattr(sys, '_eaios_function_registry'):
    # 首次加载时初始化
    sys._eaios_function_registry = {
        'registered_funcs': []
    }

def ensure_init_file():
    os.makedirs(BASE_SKILL_PATH, exist_ok=True)
    if not os.path.exists(INIT_FILE):
        with open(INIT_FILE, "w") as f:
            f.write("# Auto-generated by @eaios.api\n__all__ = []\n")

def update_import_and_all(func_name: str, full_module_path: str):
    ensure_init_file()
    import_line = f"from {full_module_path} import {func_name}"

    with open(INIT_FILE, "r+") as f:
        content = f.read()
        lines = content.splitlines()

        if import_line not in lines:
            lines.append(import_line)

        all_list = []
        found_all = False
        new_lines = []
        for line in lines:
            if line.strip().startswith("__all__"):
                try:
                    parsed = ast.parse(line)
                    assign = parsed.body[0]
                    if isinstance(assign, ast.Assign) and isinstance(assign.value, ast.List):
                        all_list = []
                        for elt in assign.value.elts:
                            if isinstance(elt, ast.Constant):
                                all_list.append(elt.value)
                            elif hasattr(elt, 's'):  # for compatibility
                                all_list.append(elt.s)
                        if func_name not in all_list:
                            all_list.append(func_name)
                    found_all = True
                    new_line = f"__all__ = {sorted_repr(all_list)}"
                    new_lines.append(new_line)
                except Exception:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        if not found_all:
            new_lines.insert(1, f"__all__ = {sorted_repr([func_name])}")

        f.seek(0)
        f.write("\n".join(new_lines) + "\n")
        f.truncate()

def sorted_repr(str_list):
    return "[" + ", ".join(f'"{s}"' for s in sorted(set(str_list))) + "]"

class FunctionRegistry:
    @staticmethod
    def add_function(func_name, module_name):
        sys._eaios_function_registry['registered_funcs'].append((func_name, module_name))
    
    @staticmethod
    def get_functions():
        return sys._eaios_function_registry['registered_funcs'].copy()
    
    @staticmethod
    def gen_lens():
        return len(sys._eaios_function_registry['registered_funcs'])


class eaios:
    mcp = FastMCP(
        name="eaios",
        host="127.0.0.1",
        port=8001,
        sse_path="/sse",
        message_path="/messages/"
    )
    FUNCTION_REGISTRY = {}
    @staticmethod
    def api(func):
        """
        Decorator for capabilities (cap) that automatically injects self_entity parameter.
        """
        print("eaios.__module__ =", eaios.__module__)
        print("eaios class id =", id(eaios))
        func = eaios.mcp.tool()(func)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Get the current entity context from the runtime
            from uapi.runtime.action import get_runtime
            runtime = get_runtime()
            
            # Extract self_entity from kwargs if provided, otherwise use current context
            self_entity = kwargs.pop('self_entity', None)
            if self_entity is None:
                # Try to get current entity from runtime context
                self_entity = getattr(runtime, '_current_entity', None)
            
            # Call the original function with self_entity injected
            if self_entity is not None:
                return func(self_entity=self_entity, *args, **kwargs)
            else:
                # Fallback: call without self_entity if not available
                return func(*args, **kwargs)

        full_mod = func.__module__
        print("full mod",full_mod, "function name", func.__name__)
        # print(f"[DEBUG] API 开始: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)
        # print(f"[DEBUG] API 添加后: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        
        # Mark this as a capability function
        wrapper._is_capability = True
        wrapper._original_func = func
        
        return wrapper

    @staticmethod
    def plugin(cap,name):
        def decorator(func):
            eaios.FUNCTION_REGISTRY[cap + ":" + name + ":" + func.__name__] = func
            return func
        return decorator

    def get_plugin(cap,name,func_name = None):
        if func_name == None:
            current = inspect.currentframe()
            caller = current.f_back
            func_name = caller.f_code.co_name if caller else None

        plugin_name = cap + ":" + name + ":" + func_name
        # auto raise KeyError
        # if plugin_name not in eaios.FUNCTION_REGISTRY.keys():
        #     raise 
        return eaios.FUNCTION_REGISTRY[plugin_name]

    @staticmethod
    def finalize():
        registry = FunctionRegistry()
        funcs = registry.get_functions()
        print("funcs",funcs)
        for func_name, full_mod in funcs:
            update_import_and_all(func_name, full_mod)

    @staticmethod
    def scan_dir(base_package: str, base_dir: str):
        """
        自动递归导入 base_dir 下所有api（api.py 文件），触发注册，再 finalize。
        - base_package: 如 'test_api.cap.hello1.api'
        - base_dir: 绝对路径，对应 base_package 的目录
        """
        for root, dirs, files in os.walk(base_dir):
            if "__pycache__" in root: 
                continue
            if "capability" in root and "plugins" in root:
                for file in files:
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, base_dir)  # e.g., 'x/y/z.py'
                    module_parts = rel_path[:-3].replace(os.sep, ".")  # remove .py
                    module_path = f"{base_package}.{module_parts}"
                    print(module_path)

                    try:
                        importlib.import_module(module_path)
                    except Exception as e:
                        print(f"[eaios] Failed to import {module_path}: {e}")
            else:
                for file in files:
                    if file == "api.py":
                        full_path = os.path.join(root, file)
                        rel_path = os.path.relpath(full_path, base_dir)  # e.g., 'x/y/z.py'
                        module_parts = rel_path[:-3].replace(os.sep, ".")  # remove .py
                        module_path = f"{base_package}.{module_parts}"
                        print(module_path)

                        try:
                            importlib.import_module(module_path)
                        except Exception as e:
                            print(f"[eaios] Failed to import {module_path}: {e}")

    @staticmethod
    def caller(func):
        """
        装饰器：从 __init__.py 中动态导入所有 __all__ 中列出的函数
        同时支持 self_entity 参数注入，用于技能调用
        """
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Get the current entity context from the runtime
            from uapi.runtime.action import get_runtime
            runtime = get_runtime()
            
            # Extract self_entity from kwargs if provided, otherwise use current context
            self_entity = kwargs.pop('self_entity', None)
            if self_entity is None:
                # Try to get current entity from runtime context
                self_entity = getattr(runtime, '_current_entity', None)
            
            # Import skills from __init__.py
            print("[DEBUG] __file__:", __file__)
            print("[DEBUG] cwd:", os.getcwd())
            # print("[DEBUG] sys.path:",sys.path)
            skill_module = importlib.import_module("DeepEmbody.skill")  # 必须是模块路径
            print(id(skill_module),skill_module.__file__)
            print(eaios.FUNCTION_REGISTRY)
            for name in getattr(skill_module, "__all__", []):
                func.__globals__[name] = getattr(skill_module, name)
            
            # Check if the function expects self_entity as first positional argument
            import inspect
            sig = inspect.signature(func)
            params = list(sig.parameters.keys())
            
            # Call the original function with self_entity injected
            if self_entity is not None:
                if len(params) > 0 and params[0] == 'self_entity':
                    # Function expects self_entity as first positional argument
                    return func(self_entity, *args, **kwargs)
                else:
                    # Function expects self_entity as keyword argument
                    return func(self_entity=self_entity, *args, **kwargs)
            else:
                # Fallback: call without self_entity if not available
                return func(*args, **kwargs)

        # Mark this as a skill function
        wrapper._is_skill = True
        wrapper._original_func = func
        
        full_mod = func.__module__
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)
        
        return wrapper
def package_init(config_path: str):
    """
    初始化包，扫描 config_path 中的所有模块并注册。
    """
    if os.path.exists(INIT_FILE):
        os.remove(INIT_FILE)
    config_path = os.path.join(BASE_PATH, config_path)
    if not os.path.exists(config_path):
        print(f"[eaios] Error: The configuration file '{config_path}' does not exist.")
        return
    config = {}
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    for base,entrys in config.items():
        if entrys is None:
            continue
        for entry in entrys:
            entry_dir = os.path.join(BASE_PATH, base, entry)
            print("[DEBUG] entry_dir:", entry_dir)
            if not os.path.exists(entry_dir):
                print(f"[eaios] Error: The '{entry_dir}' directory was not found at '{base}'")
                continue
            base_package = f"DeepEmbody.{base}.{entry}"
            eaios.scan_dir(base_package, entry_dir)
    print("before finalize")
    eaios.finalize()
    registry = FunctionRegistry()
    print(f"[eaios] Package initialized with {registry.gen_lens()} functions registered.")

try:
    import rclpy
    from rclpy.node import Node
    from std_srvs.srv import Trigger, SetBool

    class NodeController(Node):
        def __init__(self):
            super().__init__('node_controller')


        def call_service(self, service_name, request):
            if service_name == "get_count":
                client = self.create_client(Trigger, service_name)
            elif service_name == "modify_name":
                client = self.create_client(Trigger, service_name)
            elif service_name == "shutdown_node":
                client = self.create_client(Trigger, service_name)
            
            # 调用服务
            if not client.wait_for_service(timeout_sec=10.0):
                self.get_logger().error(f'Service {service_name} not available')
                return None
            future = client.call_async(request)
            rclpy.spin_until_future_complete(self, future)
            if future.result() is not None:
                self.get_logger().info(f'Service {service_name} called successfully')
                return future.result()
            else:
                self.get_logger().error(f'Service {service_name} call failed')

except ImportError:
    print("warning: rclpy is not installed, so the NodeController is not available")
    NodeController = None

# from mcp import tool
print(id(eaios.mcp))
print("eaios.__module__ =", eaios.__module__)
print("eaios class id =", id(eaios))
@eaios.mcp.tool()
def api_change_hello(name: str) -> str:
    """修改hello的对象
    Args:
        name: 新的hello名称
    """
    # rclpy.init()
    # node = NodeController()
    # req = Trigger.Request()
    # res = node.call_service('modify_name', req)
    # func_status = f"Service modify_name response: {res.success}, message: {res.message}"
    # node.destroy_node()
    # rclpy.shutdown()
    # return func_status
    return ""

async def mcp_start():
    """异步启动MCP服务器"""
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, eaios.mcp.run, "sse")

# Example usage
if __name__ == "__main__":
    import yaml, argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, default="config/include.yaml")
    args = parser.parse_args()
    package_init(args.config)
    with open("test.txt","w") as f:
        import time
        f.write(str(time.time()))
        registry = FunctionRegistry()
        print(f"[eaios] Finalized with {registry.gen_lens()} functions registered.")
        print(eaios.FUNCTION_REGISTRY)
        # mcp_start()
