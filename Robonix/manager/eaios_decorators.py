import asyncio
import os
import importlib
import functools
import ast
from mcp.server.fastmcp import FastMCP
import yaml
import sys
import inspect
from log import logger

if os.path.abspath(os.path.dirname(__file__)) not in sys.path:
    sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from constant import BASE_SKILL_PATH, INIT_FILE, EXPORT_FILE, BASE_PATH

if os.path.dirname(BASE_PATH) not in sys.path:
    sys.path.append(os.path.dirname(BASE_PATH))

if not hasattr(sys, "_eaios_function_registry"):
    sys._eaios_function_registry = {"registered_funcs": []}


def ensure_export_file():
    os.makedirs(BASE_SKILL_PATH, exist_ok=True)

    if not os.path.exists(INIT_FILE):
        with open(INIT_FILE, "w") as f:
            f.write("# Auto-generated by @eaios.api\n__all__ = []\n")

    if not os.path.exists(EXPORT_FILE):
        with open(EXPORT_FILE, "w") as f:
            f.write("# Auto-generated by @eaios.api\n__all__ = []\n")


def update_import_and_all(func_name: str, full_module_path: str):
    ensure_export_file()
    import_line = f"from {full_module_path} import {func_name}"

    for file_path in [INIT_FILE, EXPORT_FILE]:
        with open(file_path, "r+") as f:
            content = f.read()
            lines = content.splitlines()

            if import_line not in lines:
                lines.append(import_line)

            all_list = []
            found_all = False
            new_lines = []
            for line in lines:
                if line.strip().startswith("__all__"):
                    try:
                        parsed = ast.parse(line)
                        assign = parsed.body[0]
                        if isinstance(assign, ast.Assign) and isinstance(
                            assign.value, ast.List
                        ):
                            all_list = []
                            for elt in assign.value.elts:
                                if isinstance(elt, ast.Constant):
                                    all_list.append(elt.value)
                                elif hasattr(elt, "s"):
                                    all_list.append(elt.s)
                            if func_name not in all_list:
                                all_list.append(func_name)
                        found_all = True
                        new_line = f"__all__ = {sorted_repr(all_list)}"
                        new_lines.append(new_line)
                    except Exception:
                        new_lines.append(line)
                else:
                    new_lines.append(line)

            if not found_all:
                new_lines.insert(1, f"__all__ = {sorted_repr([func_name])}")

            f.seek(0)
            f.write("\n".join(new_lines) + "\n")
            f.truncate()


def sorted_repr(str_list):
    return "[" + ", ".join(f'"{s}"' for s in sorted(set(str_list))) + "]"


class FunctionRegistry:
    @staticmethod
    def add_function(func_name, module_name):
        sys._eaios_function_registry["registered_funcs"].append(
            (func_name, module_name)
        )

    @staticmethod
    def get_functions():
        return sys._eaios_function_registry["registered_funcs"].copy()

    @staticmethod
    def gen_lens():
        return len(sys._eaios_function_registry["registered_funcs"])


class eaios:
    mcp = FastMCP(
        name="eaios",
        host="127.0.0.1",
        port=8001,
        sse_path="/sse",
        message_path="/messages/",
    )
    FUNCTION_REGISTRY = {}

    @staticmethod
    def api(func):
        func = eaios.mcp.tool()(func)

        @functools.wraps(func)
        def wrapper(**kwargs):
            if "self_entity" in kwargs:
                logger.debug(
                    f"{func.__name__}: self_entity already in kwargs, calling func directly"
                )
                return func(**kwargs)

            from Robonix.uapi.runtime.action import get_runtime

            runtime = get_runtime()

            self_entity = kwargs.pop("self_entity", None)
            if self_entity is None:
                self_entity = getattr(runtime, "_current_entity", None)

            if self_entity is not None:
                import inspect

                sig = inspect.signature(func)
                if "self_entity" in sig.parameters:
                    kwargs["self_entity"] = self_entity
                    return func(**kwargs)
                else:
                    return func(**kwargs)
            else:
                return func(**kwargs)

        full_mod = func.__module__
        logger.debug(f"Full module: {full_mod}, function name: {func.__name__}")
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)

        wrapper._is_capability = True
        wrapper._original_func = func

        return wrapper

    @staticmethod
    def plugin(cap, name):
        def decorator(func):
            eaios.FUNCTION_REGISTRY[cap + ":" + name + ":" + func.__name__] = func
            return func

        return decorator

    def get_plugin(cap, name, func_name=None):
        if func_name == None:
            current = inspect.currentframe()
            caller = current.f_back
            func_name = caller.f_code.co_name if caller else None

        plugin_name = cap + ":" + name + ":" + func_name
        return eaios.FUNCTION_REGISTRY[plugin_name]

    @staticmethod
    def finalize():
        registry = FunctionRegistry()
        funcs = registry.get_functions()
        logger.debug(f"Registered functions: {funcs}")
        for func_name, full_mod in funcs:
            update_import_and_all(func_name, full_mod)

    @staticmethod
    def scan_dir(base_package: str, base_dir: str):
        for root, dirs, files in os.walk(base_dir):
            if "__pycache__" in root:
                continue
            if "capability" in root and "plugins" in root:
                for file in files:
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, base_dir)
                    module_parts = rel_path[:-3].replace(os.sep, ".")
                    module_path = f"{base_package}.{module_parts}"
                    logger.debug(f"Importing module: {module_path}")

                    try:
                        importlib.import_module(module_path)
                    except Exception as e:
                        logger.error(f"Failed to import {module_path}: {e}")
            else:
                for file in files:
                    if file == "api.py":
                        full_path = os.path.join(root, file)
                        rel_path = os.path.relpath(full_path, base_dir)
                        module_parts = rel_path[:-3].replace(os.sep, ".")
                        module_path = f"{base_package}.{module_parts}"
                        logger.debug(f"Importing module: {module_path}")

                        try:
                            importlib.import_module(module_path)
                        except Exception as e:
                            logger.error(f"Failed to import {module_path}: {e}")

    @staticmethod
    def caller(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            from Robonix.uapi.runtime.action import get_runtime

            runtime = get_runtime()

            self_entity = kwargs.pop("self_entity", None)
            if self_entity is None:
                self_entity = getattr(runtime, "_current_entity", None)

            logger.debug(f"__file__: {__file__}")
            logger.debug(f"cwd: {os.getcwd()}")
            skill_module = importlib.import_module("Robonix.skill")
            logger.debug(
                f"Skill module id: {id(skill_module)}, file: {skill_module.__file__}"
            )
            logger.debug(f"Function registry: {eaios.FUNCTION_REGISTRY}")
            for name in getattr(skill_module, "__all__", []):
                func.__globals__[name] = getattr(skill_module, name)

            import inspect

            sig = inspect.signature(func)

            kwargs["self_entity"] = self_entity

            return func(**kwargs)

        wrapper._is_skill = True
        wrapper._original_func = func

        full_mod = func.__module__
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)

        return wrapper


def package_init(config_path: str):
    for file_path in [INIT_FILE, EXPORT_FILE]:
        if os.path.exists(file_path):
            os.remove(file_path)

    config_path = os.path.join(BASE_PATH, config_path)
    if not os.path.exists(config_path):
        logger.error(f"The configuration file '{config_path}' does not exist.")
        return
    config = {}
    with open(config_path, "r", encoding="utf-8") as f:
        config = yaml.safe_load(f)
    for base, entrys in config.items():
        if entrys is None:
            continue
        for entry in entrys:
            entry_dir = os.path.join(BASE_PATH, base, entry)
            logger.debug(f"Entry directory: {entry_dir}")
            if not os.path.exists(entry_dir):
                logger.error(f"The '{entry_dir}' directory was not found at '{base}'")
                continue
            base_package = f"Robonix.{base}.{entry}"
            eaios.scan_dir(base_package, entry_dir)
    logger.debug("Before finalize")
    eaios.finalize()
    registry = FunctionRegistry()
    logger.info(f"Package initialized with {registry.gen_lens()} functions registered.")
    logger.info(f"Updated both {INIT_FILE} and {EXPORT_FILE} for code migration.")


try:
    import rclpy
    from rclpy.node import Node
    from std_srvs.srv import Trigger, SetBool

    class NodeController(Node):
        def __init__(self):
            super().__init__("node_controller")

        def call_service(self, service_name, request):
            if service_name == "get_count":
                client = self.create_client(Trigger, service_name)
            elif service_name == "modify_name":
                client = self.create_client(Trigger, service_name)
            elif service_name == "shutdown_node":
                client = self.create_client(Trigger, service_name)

            if not client.wait_for_service(timeout_sec=10.0):
                self.get_logger().error(f"Service {service_name} not available")
                return None
            future = client.call_async(request)
            rclpy.spin_until_future_complete(self, future)
            if future.result() is not None:
                self.get_logger().info(f"Service {service_name} called successfully")
                return future.result()
            else:
                self.get_logger().error(f"Service {service_name} call failed")

except ImportError:
    logger.warning("rclpy is not installed, so the NodeController is not available")
    NodeController = None

logger.debug(f"MCP id: {id(eaios.mcp)}")
logger.debug(f"eaios.__module__ = {eaios.__module__}")
logger.debug(f"eaios class id = {id(eaios)}")


@eaios.mcp.tool()
def api_change_hello(name: str) -> str:
    return ""


async def mcp_start():
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, eaios.mcp.run, "sse")


if __name__ == "__main__":
    import yaml, argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, default="config/include.yaml")
    args = parser.parse_args()
    package_init(args.config)
    with open("test.txt", "w") as f:
        import time

        f.write(str(time.time()))
        registry = FunctionRegistry()
        logger.info(f"Finalized with {registry.gen_lens()} functions registered.")
        logger.debug(f"Function registry: {eaios.FUNCTION_REGISTRY}")
